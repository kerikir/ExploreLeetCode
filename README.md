# Заметки о производительности в Kotlin

1. `size` у коллекции быстрее и тратит меньше памяти, чем `lastIndex`.  
2. `until` менее оптимизирован по памяти, чем `..` и `..<`.    
3. Чаще всего `sum = sum + value` показывает себя хуже по памяти, чем `sum += value`, но не на много.   
4. `accounts.maxOf { it.sum() }` медленне и больше по памяти, чем своя реализация итерации.  
5. Метод `max()` лучше оптимизирован по памяти, чем своя реализация с `if`.  
6. `array.indices` лучше оптимизирован по памяти, чем `0..<accounts.size`.
7. `while` лучше себя показывает при работе, чем `for` с использованием диапазона.
8. Переменные `String`, которые сбрасываются в цикле (используются только в нем), лучше объявлять в цикле по производительности, чем вне цикла.
9. Переменные `Boolean`, которые сбрасываются в цикле, лучше объявлять вне цикла, как `var`, чем в цикле.
10. Объявление `var` переменных в цикле лучше по производительности, чем `val` переменные в цикле.
11. Цикл `while` с дополнительной переменной для номера итерации лучше по памяти, чем цикл `for`.
12. `x and 1 == 0` более оптимизированно по памяти, чем `x % 2 == 0`.
13. `x = x shr 1` более оптимизированно по памяти, чем `x = x / 2`.
14. `x /= 2` более оптимизированно по памяти, чем `x = x / 2`.
15. Для памяти лучше не создавать дополнительные переменные, если можно вставить в условие.
16. `x--` чуть лучше оптимизирован по памяти, чем `x and 0b11111111111111111110` (сброс правого крайнего бита в 0).
17. Префиксный декремент `--x` гораздо хуже оптимизирован по памяти, чем постфиксный декремент `x--`.
18. Однострочная функция хуже по оптимизации (потреблению памяти), чем обычная.
19. 



</br></br>


# Заметки об алгоритме

1. Префиксная сумма - вместо того, чтобы вычислять сумму элементов сначала массива, мы используем значение сохраненное на предыдущем месте.
2. В пространственную сложность не включается массив входных и выходных данных.
3. Можно изменять входной массив, если в будующем он не будет использоваться.
4. В пространственную сложность входит память, которая облегчает решение задачи.
5. Сначала проверяется более узкое условие, так как при выполнение одного из условий проверка других условий не произойдет.
6. Для умножения и деления на 2 удобно использовать битовое представление (сдвиги).
7. Четность числа можно проверить с помощью крайнего правого бита (0 - четное число, а 1 - нечетное). Проверяется с помощью конъюнкции с `0b01`.
8. 
